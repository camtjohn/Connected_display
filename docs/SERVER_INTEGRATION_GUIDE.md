# Server Integration Guide for Connected Display Device
**Last Updated:** January 9, 2026  
**Device Firmware Version:** 1.0  
**Protocol Version:** Binary MQTT Protocol v1.0

---

## Table of Contents
1. [Overview](#overview)
2. [MQTT Broker Configuration](#mqtt-broker-configuration)
3. [Device Boot & Registration](#device-boot--registration)
4. [Message Protocols](#message-protocols)
5. [Topic Structure](#topic-structure)
6. [Security & Authentication](#security--authentication)
7. [Error Handling](#error-handling)
8. [OTA Updates](#ota-updates)
9. [Testing & Validation](#testing--validation)

---

## Overview

The Connected Display is an ESP32-S3 based device that communicates with an MQTT broker for weather updates, shared views (collaborative drawing), and device management. All messages use a **binary protocol** for efficiency.

### Key Features
- **Binary MQTT Protocol**: Efficient message encoding with 2-byte headers
- **TLS/SSL Security**: Secure MQTT connection on port 8883
- **Weather Updates**: Real-time current weather and forecast data
- **Shared View**: Collaborative drawing canvas synchronization
- **OTA Updates**: Remote firmware updates via version notifications
- **Device Registration**: Automatic device configuration on boot

### Server Requirements
- MQTT Broker with TLS support (port 8883)
- Valid TLS certificate
- Support for QoS 0 and QoS 1 messages
- Last Will and Testament (LWT) support

---

## MQTT Broker Configuration

### Connection Details
```
Protocol: MQTTS (MQTT over TLS)
Default URL: mqtts://jbar.dev:8883
Port: 8883
Client ID: Auto-generated by device
Keep-Alive: 120 seconds (default)
```

### TLS Certificate
- Device requires server CA certificate to validate broker
- Certificate stored in device NVS (Non-Volatile Storage)
- Certificate provisioning via separate provisioning tool

### Last Will and Testament (LWT)
The device does NOT currently configure LWT. Server should implement timeout-based detection for offline devices using heartbeat monitoring.

---

## Device Boot & Registration

### Boot Sequence
When the device connects to MQTT broker, it performs the following:

1. **Connect to Broker**
2. **Subscribe to Topics** (see Topic Structure below)
3. **Publish Device Configuration**

### Device Configuration Message
**Topic:** `dev_bootup` (production) or `debug_dev_bootup` (debug)  
**Message Type:** `0x03` (MSG_TYPE_DEVICE_CONFIG)  
**QoS:** 1

### Device Configuration Message
**Topic:** `dev_bootup` (production) or `debug_dev_bootup` (debug)  
**Message Type:** `0x03` (MSG_TYPE_DEVICE_CONFIG)  
**QoS:** 1

**Purpose:** Device publishes this message when it connects to the broker. It contains the device's name and zipcode configuration.

**Format:**
```
[Type: 0x03][Length][NumStrings][Str1Len][Str1Bytes...][Str2Len][Str2Bytes...]...
```

**Structure Breakdown:**
- **Byte 0**: Message type = `0x03`
- **Byte 1**: Total payload length (everything after this byte)
- **Byte 2**: Number of strings in the payload (always `0x02` for device config: name + zipcode)
- **String 1** (device name):
  - 1 byte: length of device name string
  - N bytes: UTF-8 encoded device name
- **String 2** (zipcode):
  - 1 byte: length of zipcode string  
  - N bytes: UTF-8 encoded zipcode

**Example:**
```
Device Name: "dev0" (4 bytes)
Zipcode: "60607" (5 bytes)

Complete Message (14 bytes total):
[0x03]        // Type: device_config
[0x09]        // Length: 9 bytes of payload follow
[0x02]        // NumStrings: 2 strings
[0x04]        // String 1 length: 4 bytes
[0x64]        // 'd'
[0x65]        // 'e'
[0x76]        // 'v'
[0x30]        // '0'
[0x05]        // String 2 length: 5 bytes
[0x36]        // '6'
[0x30]        // '0'
[0x36]        // '6'
[0x30]        // '0'
[0x37]        // '7'
```

**Server Action Upon Receiving:**
- Extract device name and zipcode
- Create or update device record in database
- Mark device as online
- Subscribe/route weather updates to topic: `weather/<zipcode>` or `debug_weather/<zipcode>`

**Parsing Notes:**
- Read the full message with header included
- Use the Length field to know how many bytes of payload to read
- Loop through NumStrings times, reading each length-prefixed string
- First string is always device name, second is always zipcode

---

**Server Action:**
- Store device_name and zipcode mapping
- Update device online status
- Initialize weather topic routing: `weather/<zipcode>`

---

## Message Protocols

### Binary Message Structure
All messages follow this format:
```
[Type: 1 byte][Length: 1 byte][Payload: 0-255 bytes]
```

### 1. Current Weather Update
**Direction:** Server → Device  
**Topic:** `weather/<zipcode>` (e.g., `weather/60607`)  
**Message Type:** `0x01` (MSG_TYPE_CURRENT_WEATHER)

**Format:**
```
[0x01][0x01][Temperature]
```

**Temperature Encoding:**
- Temperature is encoded with +50 offset to handle negative values
- Formula: `encoded_temp = actual_temp + 50`
- Range: -50°F to +205°F (encoded as 0-255)

**Example:**
```
Actual Temperature: 20°F
Encoded: 20 + 50 = 70 (0x46)
Message: [0x01][0x01][0x46]
```

---

### 2. Forecast Weather Update
**Direction:** Server → Device  
**Topic:** `weather/<zipcode>`  
**Message Type:** `0x02` (MSG_TYPE_FORECAST_WEATHER)

**Format:**
```
[0x02][Length][NumDays][Day1_High][Day1_Precip][Day1_Moon]...[DayN_High][DayN_Precip][DayN_Moon]
```

**Fields:**
- `NumDays`: Number of forecast days (1-7)
- `Day_High`: High temperature in °F (no offset, direct value 0-255)
- `Day_Precip`: Precipitation percentage (0-100)
- `Day_Moon`: Moon phase (0=<93%, 1=93-99%, 2=100% full)

**Example (3-day forecast):**
```
Day 1: High 75°F, 20% precip, 95% moon (phase 1)
Day 2: High 80°F, 0% precip, 100% moon (phase 2)
Day 3: High 78°F, 50% precip, 92% moon (phase 0)

Binary Message:
[0x02]        // Message type
[0x0A]        // Length (10 bytes: 1 + 3*3)
[0x03]        // 3 days
[0x4B]        // Day 1 high (75)
[0x14]        // Day 1 precip (20%)
[0x01]        // Day 1 moon (phase 1)
[0x50]        // Day 2 high (80)
[0x00]        // Day 2 precip (0%)
[0x02]        // Day 2 moon (phase 2)
[0x4E]        // Day 3 high (78)
[0x32]        // Day 3 precip (50%)
[0x00]        // Day 3 moon (phase 0)
```

---

### 3. Version Notification (OTA Trigger)
**Direction:** Server → Device  
**Topic:** `<device_name>` (e.g., `dev0` or `debug_dev0`)  
**Message Type:** `0x10` (MSG_TYPE_VERSION)

**Format:**
```
[0x10][0x01][Version]
```

**Device Behavior:**
- Compares received version with current firmware version
- If received version > current version, triggers OTA update
- Device reboots to factory partition for OTA update

**Example:**
```
New Version: 5

Binary Message:
[0x10][0x01][0x05]
```

---

### 4. Shared View Messages (Collaborative Drawing)

#### 4a. Shared View Request
**Direction:** Device → Server (or Device ↔ Device via broker)  
**Topic:** `shared_view` (production) or `debug_shared_view` (debug)  
**Message Type:** `0x20` (MSG_TYPE_SHARED_VIEW_REQ)

**Format:**
```
[0x20][0x00]
```

**Purpose:** Request a full frame update from the current publisher

---

#### 4b. Shared View Frame (Full Update)
**Direction:** Server/Device → Devices  
**Topic:** `shared_view`  
**Message Type:** `0x21` (MSG_TYPE_SHARED_VIEW_FRAME)

**Format:**
```
[0x21][0x62]
  [Seq_High][Seq_Low]
  [Red_Rows: 16×2 bytes]
  [Green_Rows: 16×2 bytes]
  [Blue_Rows: 16×2 bytes]
```

**Total Size:** 2 + 2 + 96 = 100 bytes (header + seq + pixel data)

**Structure:**
- `Seq`: 16-bit sequence number (big-endian/network order)
- Each color has 16 rows
- Each row is a 16-bit bitmask (2 bytes) representing 16 columns
- Bit set = pixel is that color

**Example:**
```
Sequence: 1000 (0x03E8)
Red row 0: bits 0,1,2 set (0x0007)
Green row 0: bits 4,5 set (0x0030)
Blue row 0: bits 8 set (0x0100)

Binary Message (abbreviated):
[0x21][0x62]
[0x03][0xE8]     // Sequence 1000
[0x07][0x00]     // Red row 0 (little-endian uint16)
...              // Red rows 1-15
[0x30][0x00]     // Green row 0
...              // Green rows 1-15
[0x00][0x01]     // Blue row 0
...              // Blue rows 1-15
```

**Note:** Row bitmasks are transmitted as raw uint16 values in the platform's native byte order (likely little-endian for ESP32).

---

#### 4c. Shared View Updates (Incremental)
**Direction:** Server/Device → Devices  
**Topic:** `shared_view`  
**Message Type:** `0x22` (MSG_TYPE_SHARED_VIEW_UPDATES)

**Format:**
```
[0x22][Length]
  [Seq_High][Seq_Low]
  [Count]
  [Row][Col][Color]  // Repeat Count times
  ...
```

**Fields:**
- `Seq`: 16-bit sequence number (big-endian)
- `Count`: Number of pixel updates
- `Row`: 0-15
- `Col`: 0-15
- `Color`: 0=Red, 1=Green, 2=Blue

**Example (2 pixels):**
```
Sequence: 1001
Pixel 1: row=5, col=10, color=Red(0)
Pixel 2: row=7, col=3, color=Blue(2)

Binary Message:
[0x22][0x08]     // Type and length
[0x03][0xE9]     // Sequence 1001
[0x02]           // 2 updates
[0x05][0x0A][0x00]  // Pixel 1
[0x07][0x03][0x02]  // Pixel 2
```

**Synchronization:**
- Devices track last received sequence number
- If sequence gap detected (seq != last_seq + 1), device sends Shared View Request
- Server/publisher responds with full frame (0x21)

---

## Topic Structure

### Production Topics
| Topic | Direction | Purpose | QoS |
|-------|-----------|---------|-----|
| `weather/<zipcode>` | Server → Device | Weather updates (0x01, 0x02) | 0 |
| `<device_name>` | Server → Device | Device-specific messages (0x10) | 1 |
| `dev_bootup` | Device → Server | Device registration (0x03) | 1 |
| `dev_heartbeat` | Device → Server | Periodic heartbeat (future) | 0 |
| `device_offline` | Device → Server | LWT message (future) | 1 |
| `shared_view` | Bidirectional | Shared canvas (0x20, 0x21, 0x22) | 0 |
| `debug` | Device → Server | Debug messages (text) | 1 |

### Debug Topics (DEBUG_BUILD flag enabled)
All production topics prefixed with `debug_`:
- `debug_weather/<zipcode>`
- `debug_dev0`
- `debug_dev_bootup`
- `debug_dev_heartbeat`
- `debug_device_offline`
- `debug_shared_view`
- `debug_test_msg`

**Server Implementation Note:** Support both production and debug topic schemes for development/testing environments.

---

## Security & Authentication

### TLS Configuration
```
Protocol: TLS 1.2 or higher
Port: 8883
Certificate Validation: Required
```

### Device Certificate Storage
- CA certificate stored in device NVS
- Provisioned during manufacturing or initial setup
- Certificate update requires reprovisioning

### Certificate Provisioning Process
1. Device enters provisioning mode
2. Connects to provisioning tool via USB or WiFi AP
3. Tool writes certificate to NVS partition
4. Device validates certificate and reboots

**Provisioning Tools Location:** `provision_display/` directory

---

## Error Handling

### Device Behavior

#### Connection Failures
- Device retries connection with exponential backoff
- Max retry attempts: Unlimited (will retry indefinitely)
- Retry interval: 5s, 10s, 20s, 40s, 60s (max)

#### Message Validation
- Device validates message type and length
- Invalid messages logged and discarded
- No error messages sent back to server

#### Duplicate Detection
- Device stores last received weather message (binary)
- Duplicates are detected and not processed
- Reduces unnecessary display updates

### Server Recommendations

#### Message Publishing
- Validate message format before publishing
- Use QoS 1 for critical messages (version, device config)
- Use QoS 0 for high-frequency messages (weather, shared view)

#### Device Monitoring
- Track device registration (dev_bootup messages)
- Implement timeout for heartbeat monitoring (if implemented)
- Monitor debug topic for device logs

#### Rate Limiting
- Weather updates: Max 1/minute per device recommended
- Shared view updates: Up to 10/second supported
- Version checks: Max 1/hour recommended

---

## OTA Updates

### Update Flow
```
1. Server publishes version message (0x10) to device topic
2. Device compares version with current firmware
3. If new version available:
   a. Device sets NVS flag to boot to factory partition
   b. Device reboots
   c. Factory app performs OTA download
   d. Factory app validates new firmware
   e. Device boots to new firmware
   f. Device marks firmware as valid
```

### Factory Partition
- Minimal firmware with OTA capability
- No weather display functionality
- Download URL: Hardcoded or configured in NVS

### OTA Server Requirements
- HTTPS server with valid certificate
- Binary firmware file (.bin)
- Version metadata (JSON or headers)

### Version Management
- Version stored as single uint8 (0-255)
- Higher number = newer version
- Version reset/wraparound not supported

---

## Testing & Validation

### Test Message Examples

#### Test Current Weather (75°F)
```bash
mosquitto_pub -h jbar.dev -p 8883 \
  --cafile ca.crt \
  -t "weather/60607" \
  -m "\x01\x01\x7D" \
  -q 0
```

#### Test Forecast (1 day, 80°F, 20% precip, full moon)
```bash
mosquitto_pub -h jbar.dev -p 8883 \
  --cafile ca.crt \
  -t "weather/60607" \
  -m "\x02\x04\x01\x50\x14\x02" \
  -q 0
```

#### Test Version Update (Version 5)
```bash
mosquitto_pub -h jbar.dev -p 8883 \
  --cafile ca.crt \
  -t "dev0" \
  -m "\x10\x01\x05" \
  -q 1
```

### Python Test Script
```python
import paho.mqtt.client as mqtt
import ssl

def publish_current_weather(client, zipcode, temp_f):
    encoded_temp = int(temp_f) + 50
    message = bytes([0x01, 0x01, encoded_temp])
    client.publish(f"weather/{zipcode}", message, qos=0)

def publish_forecast(client, zipcode, days):
    payload = [len(days)]
    for day in days:
        payload.append(int(day['high']))
        payload.append(int(day['precip_pct']))
        moon_pct = day['moon_pct']
        moon_phase = 0 if moon_pct < 93 else (1 if moon_pct < 100 else 2)
        payload.append(moon_phase)
    
    message = bytes([0x02, len(payload)] + payload)
    client.publish(f"weather/{zipcode}", message, qos=0)

def publish_version(client, device_name, version):
    message = bytes([0x10, 0x01, version])
    client.publish(device_name, message, qos=1)

# Connection setup
client = mqtt.Client()
client.tls_set(ca_certs="ca.crt", tls_version=ssl.PROTOCOL_TLSv1_2)
client.connect("jbar.dev", 8883, 60)

# Example usage
publish_current_weather(client, "60607", 72)
publish_forecast(client, "60607", [
    {'high': 75, 'precip_pct': 20, 'moon_pct': 95},
    {'high': 80, 'precip_pct': 0, 'moon_pct': 100},
    {'high': 78, 'precip_pct': 50, 'moon_pct': 92}
])
publish_version(client, "dev0", 5)

client.disconnect()
```

---

## Appendix: Quick Reference

### Message Type Summary
| Type | Hex | Name | Direction | Payload Size |
|------|-----|------|-----------|--------------|
| Current Weather | 0x01 | MSG_TYPE_CURRENT_WEATHER | Server → Device | 1 byte |
| Forecast Weather | 0x02 | MSG_TYPE_FORECAST_WEATHER | Server → Device | 1 + (3×days) |
| Device Config | 0x03 | MSG_TYPE_DEVICE_CONFIG | Device → Server | Variable |
| Version | 0x10 | MSG_TYPE_VERSION | Server → Device | 1 byte |
| Shared View Request | 0x20 | MSG_TYPE_SHARED_VIEW_REQ | Bidirectional | 0 bytes |
| Shared View Frame | 0x21 | MSG_TYPE_SHARED_VIEW_FRAME | Bidirectional | 98 bytes |
| Shared View Updates | 0x22 | MSG_TYPE_SHARED_VIEW_UPDATES | Bidirectional | 3 + (3×count) |

### Temperature Encoding
- **Current Weather**: `encoded = actual + 50`
- **Forecast**: Direct value (no offset)

### Moon Phase Encoding
- 0: Less than 93% illumination
- 1: 93-99% illumination
- 2: 100% full moon

---

## Support & Contact

For questions or issues with device integration:
- Review existing documentation in project repository
- Check MQTT broker logs for connection/authentication errors
- Monitor device debug topic for device-side logs
- Reference files: `MQTT_PROTOCOL.md`, `PROVISIONING_IMPLEMENTATION.md`

**Server Integration Checklist:**
- [ ] MQTT broker configured with TLS on port 8883
- [ ] CA certificate properly configured
- [ ] Topic structure matches production/debug mode
- [ ] Binary message encoding implemented correctly
- [ ] Device registration handler for `dev_bootup` messages
- [ ] Weather update publisher for device zipcodes
- [ ] Version notification system for OTA updates
- [ ] Shared view message handling (if using collaborative features)
- [ ] Rate limiting and error handling implemented
- [ ] Test messages validated with actual device

---

**Document Version:** 1.0  
**Last Updated:** January 9, 2026
